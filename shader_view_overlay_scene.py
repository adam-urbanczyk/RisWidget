# The MIT License (MIT)
#
# Copyright (c) 2014-2015 WUSTL ZPLAB
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Authors: Erik Hvatum <ice.rikh@gmail.com>

#from PyQt5 import Qt
#
#class ShaderViewOverlayScene(Qt.QGraphicsScene):
#    def __init__(self, shader_scene, parent):
#        super().__init__(parent)
#        self.shader_scene = shader_scene
#        self.add_mouseover_info_item()
#
#    def add_mouseover_info_item(self):
#        f = Qt.QFont('Courier', 14)
#        f.setKerning(False)
#        f.setStyleHint(Qt.QFont.Monospace, Qt.QFont.OpenGLCompatible | Qt.QFont.PreferQuality)
#        self.mouseover_text_item = self.addText('', f)
#        self.shader_scene.update_mouseover_info_signal.connect(self.on_update_mouseover_info)
#        c = Qt.QColor(Qt.Qt.green)
#        c.setAlphaF(.75)
#        self.mouseover_text_item.setDefaultTextColor(c)
#
#    def on_update_mouseover_info(self, string, is_html):
#        if is_html:
#            self.mouseover_text_item.setHtml(string)
#        else:
#            self.mouseover_text_item.setPlainText(string)
#
#    def set_mouseover_info_item_visibility(self, visible):
#        self.mouseover_text_item.setVisible(visible)

# At some point, in order to make overlay plane interactive, it will be necessary to either make the below
# work, or modestly rearchitect overlay rendering (not hard to do - it consists of a single ShaderViewOverlayScene.render
# call, which would be replaced by a blit operation, and associating an offscreen view with the overlay scene), as
# discussed here:
# http://www.riverbankcomputing.com/pipermail/pyqt/2015-March/035663.html

#   def eventFilter(self, watched, event):
#       print(watched, type(event))
#       if watched is self.shader_scene and issubclass(type(event), (Qt.QGraphicsSceneEvent, Qt.QKeyEvent, Qt.QFocusEvent, Qt.QTimerEvent)) or type(event) is Qt.QEvent and event.type() is Qt.QEvent.MetaCall:
#           if hasattr(event, 'screenPos') and issubclass(type(event), Qt.QGraphicsSceneEvent):
#               event.setScenePos(event.widget().mapFromGlobal(event.screenPos()))
#               print(event.screenPos(), event.widget().mapFromGlobal(event.screenPos()))
#           return self.event(event)
#       else:
#           return super().eventFilter(watched, event)

# The problem of needing to and being unable to modify scenePos attributes of QGraphicsScene*Events
# received by a QGraphicsView that needs to try these events against a QGraphicsScene other than its own
# may be avoided by associating an offscreen QGraphicsView with the orphan QGraphicsScene.  The offscreen
# QGraphicsView may then filter the ShaderView's events in order to translate raw Q*Events (eg QMouseEvent)
# into QGraphics*Events counterparts (eg QGraphicsSceneMouseEvent) as it normally would, which includes
# marking the original Q*Events as accepted if and only if their QGraphics*Events were accepted.  Thus,
# if no overlay item has anything useful to do with the event, the event would pass to the ShaderView,
# which would, in turn, convert the Q*Event into a QGraphicsScene*Event (with correct scenePos attributes,
# different from those generated by the offscreen view for the overlay scene) and test it against its own
# scene.

#class ShaderViewOverlayView(Qt.QGraphicsView):
#    def event(self, event):
#        if event.type() == Qt.QEvent.Paint:
#            event.accept()
#            return True
#        return super().event(event)
